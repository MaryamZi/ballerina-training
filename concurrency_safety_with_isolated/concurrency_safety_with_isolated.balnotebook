[{"kind":1,"language":"markdown","value":"### Mutability","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"int[] & readonly a = [];\na[0] = 1; // cannot update 'readonly' value of type '(int[] & readonly)'\na = [1]; // OK\n\nfinal int[] b = [];\nb[0] = 1; // OK\nb = [1]; // cannot assign a value to final 'b'\n\nfinal int[] & readonly c = [];\nc[0] = 1; // cannot update 'readonly' value of type '(int[] & readonly)'\nc = [1]; // cannot assign a value to final 'c'","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"### Workers, async calls, strands, and threads\n\nQuoting the [spec](https://ballerina.io/spec/lang/master/#section_7.2)\n\n> Ballerina's concurrency model supports both threads and coroutines. A Ballerina program is executed on one or more threads. A thread may run on a separate core simultaneously with other threads, or may be pre-emptively multitasked with other threads onto a single core.\n\n> Each thread is divided into one or more strands. No two strands belonging to the same thread can run simultaneously. Instead, all the strands belonging to a particular thread are cooperatively multitasked. Strands within the same thread thus behave as coroutines relative to each other. A strand enables cooperative multitasking by yielding. When a strand yields, the runtime scheduler may suspend execution of the strand, and switch its thread to executing another strand.\n\nWorkers are scheduled on the same thread as the parent strand, unless the workers are (inferred to be) isolated.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"// bal run isolated.bal -- 1 2 3 4\npublic function main(int... ints) returns error? {\n    // default-worker-init\n    // ...\n\n    worker w returns int {\n        int sum = 0;\n        foreach int i in ints {\n            sum += i;\n        }\n        return sum;\n    }\n\n    future<int> startFut = start int:sum(...ints);\n\n    future<int> workerFut = w;\n\n    int startSum = check wait startFut;\n    int workerSum = check wait workerFut;\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"### Why `isolated`?\n\nWith workers (on different threads) running concurrently, there could be data races (and therefore, problems), when accessing mutable state from these workers.\n\n#### Where is this specifically a problem in Ballerina?\n\nTwo entry points in Ballerina:\n- the `main` function\n- services\n\nWhile applicable to the `main` (or any other entry) function, main requirements for concurrency and concurrency safety are with services, when listeners call resource or remote methods of services.\n\nE.g., how does the listener decide whether it is safe to dispatch request concurrently to remote/resource methods of the same service.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"import ballerina/http;\n\nenum CakeKind {\n    BUTTER_CAKE = \"Butter Cake\",\n    CHOCOLATE_CAKE = \"Chocolate Cake\",\n    TRES_LECHES = \"Tres Leches\"\n}\n\nenum OrderStatus {\n    PENDING = \"pending\",\n    IN_PROGRESS = \"in progress\",\n    COMPLETED = \"completed\"\n}\n\ntype OrderDetail record {|\n    CakeKind item;\n    int quantity;\n|};\n\ntype Order record {|\n    string username;\n    OrderDetail[] order_items;\n|};\n\nmap<Order> orders = {};\nmap<OrderStatus> orderStatus = {};\nint orderId = 1000; // just for demonstration\n\nservice on new http:Listener(8080) {\n    resource function post 'order(Order newOrder) returns http:Created|http:BadRequest? {\n        // ...\n\n        string orderId = nextOrderId();\n\n        orders[orderId] = newOrder;\n\n        orderStatus[orderId] = PENDING;\n\n        // ...\n        return http:CREATED;\n    }\n}\n\nfunction nextOrderId() returns string {\n    int nextOrderId = orderId;\n    orderId += 1;\n    return nextOrderId.toString();\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"`isolated` and related concepts are Ballerina's attempt at ensuring compile-time guaranteed concurrency safety.\n\nHelps identify which functions/methods can safely be called concurrently.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"### Isolated functions\n\nA function that is safe to be called concurrently, as long as the caller can guarantee that the arguments are safe.\n\nArgument safety:\n- If the parameters allow only immutable valuables, the arguments are inherently safe, since the values passed as arguments cannot be updated.\n- Also safe if the caller can guarantee that a mutable value passed as an argument is not accessed elsewhere until the function call completes (e.g., using lock statements).","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"import ballerina/http;\n \ntype Order record {\n    string id;\n    string status;\n    // ...\n};\n\nservice on new http:Listener(8080) {\n    resource function post r1(Order ord) {\n        // Alternatively, change the param type of the resource if that's possible. \n        f1(ord.cloneReadOnly()); \n    }\n\n    resource function post r2(Order ord) {\n        f2(ord);\n    }\n\n    resource function post r3(Order & readonly ord) {\n        f3(ord);\n    }\n}\n\nfunction f1(Order & readonly ord) {\n    string id = ord.id;\n    // ... does not access module-level mutable state\n    // Since `ord` is immutable, we know it cannot be updated here.\n}\n\n// implicitly final and the type is `map<string> & readonly`\nconfigurable map<string> statusKeys = {\n    pending: \"Pending\",\n    in\\-progress: \"In Progress\",\n    completed: \"Completed\"\n};\n\nfunction f2(Order ord) {\n    string id = ord.id;\n    // Safe as long as the caller guarantees exclusive access to `ord`\n    // until this function completes.\n    // Accessing `statusKeys` is OK since it is implictly final and immutable.\n    ord.status = statusKeys.get(\"in-progress\");\n    // ... does not access module-level mutable state\n}\n\nmap<Order> orderMap = {};\n\nfunction f3(Order & readonly ord) {\n    orderMap[ord.id.toString()] = ord;\n    // Although the arguments are safe, the function accesses a mutable\n    // module-level variable, which is not safe.\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"\nNote how the first two resources are identified as `isolated`, but the third resource is not, resulting in the following hint.\n\n```bash\nconcurrent calls will not be made to this method since the method is not an 'isolated' method\n```\n\nAs seen in the code, the third resource accesses shared mutable state in an unsafe manner (e.g., without using locks), and it is not safe to call this method concurrently. Accordingly, this results in the resource being identified as a non-`isolated` method.\n\nWhile we've relied on `isolated` inference here, explicitly adding the `isolated` qualifier to the function will\n- log diagnostics to convey why a function is not `isolated`\n- guarantee that any future change guarantees that the function continues to be safe to be called concurrently (unless of course the author removes isolated :))\n\nAn `isolated` function defines several requirements, including \n- an `isolated` function can only call other functions/methods if they too are `isolated`\n- restrictions on accessing module-level variables\n- restrictions on async calls from within such functions\n\nAlso see the [spec]( https://ballerina.io/spec/lang/master/#isolated_functions).\n\nLet's mark some of the constructs as `isolated` explicitly and check the errors.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"import ballerina/http;\n\ntype Order record {\n    string id;\n    string status;\n    // ...\n};\n\nservice on new http:Listener(8080) {\n    isolated resource function post r1(Order ord) {\n        // Alternatively, change the param type of the resource if that's possible. \n        f1(ord.cloneReadOnly()); \n    }\n\n    isolated resource function post r2(Order ord) {\n        f2(ord); // invalid invocation of a non-isolated function in an 'isolated' function\n                 // While `f2` can be inferred to be `isolated`, that is not enough here.\n                 // has to be isolated explicitly.   \n    }\n\n    isolated resource function post r3(Order & readonly ord) {\n        f3(ord);\n    }\n}\n\nisolated function f1(Order & readonly ord) {\n    string id = ord.id;\n    // ... does not access module-level mutable state\n    // Since `ord` is immutable, we know it cannot be updated here.\n}\n\n// implicitly final and the type is `map<string> & readonly`\nconfigurable map<string> statusKeys = {\n    pending: \"Pending\",\n    in\\-progress: \"In Progress\",\n    completed: \"Completed\"\n};\n\nfunction f2(Order ord) {\n    string id = ord.id;\n    // Safe as long as the caller guarantees exclusive access to `ord`\n    // until this function completes.\n    // Accessing `statusKeys` is OK since it is implictly final and immutable.\n    ord.status = statusKeys.get(\"in-progress\");\n    // ... does not access module-level mutable state\n}\n\nmap<Order> orderMap = {};\n\nisolated function f3(Order & readonly ord) {\n    orderMap[ord.id.toString()] = ord; // invalid access of mutable storage in an 'isolated' function\n    // Although the arguments are safe, the function accesses a mutable\n    // module-level variable, which is not safe.\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"An `isolated` function is, therefore, a function that works with mutable state without restrictions only if the mutable state was passed as arguments.\n\n**Note**: just because a function is `isolated`, doesn't mean it is safe to call concurrently. Safety depends on the arguments also. And as we will see later, for objects (and therefore, services) depends on the object too.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"### Isolated variables\n\nBut, there may be valid requirements to access shared mutable state in a safe manner (e.g., appropriately using lock statements).","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"import ballerina/http;\n \ntype Order record {\n    string id;\n    string status;\n    // ...\n};\n\nservice on new http:Listener(8080) {\n    resource function post r3(Order & readonly ord) {\n        f3(ord);\n    }\n}\n\nmap<Order> orderMap = {};\n\nfunction f3(Order & readonly ord) {\n    lock {\n        orderMap[ord.id.toString()] = ord;\n        // OK now, since any and all access of `orderMap` happens within a lock statement\n    }\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"The hint goes away for the third resource also now.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"#### Isolated root\n\nAs implied in the previous section, an `isolated` variable can be accessed only within a lock statement.\n\nBut, are only locks enough?","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"int[] a = [1, 2];\n\nint[][] b = [a];\n\nfunction f1() {\n    lock {\n        if b[0].length() == 0 {\n            return;\n        }\n        // ...\n        int x = b[0][0];\n    }\n}\n\nfunction f2() {\n    a.removeAll();\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"Although, lock statements are used to access the array and it's members via `b`, the mutable state may be accessed without locks via other references. \n\nIsolated variables avoid this using the [isolated root](https://ballerina.io/spec/lang/master/#section_5.1.3) invariant.\n\n> A variable or value is an isolated root if its mutable state is isolated from the rest of the program's mutable state: any mutable state that is freely reachable from the isolated root is reachable from outside only through the isolated root. More precisely, if some mutable state s is freely reachable from an isolated root value r, then s is not freely reachable from a variable or value that is not reachable from r except by following a reference through r; similarly, if some mutable state s is freely reachable from an isolated root variable r, then s is not freely reachable from a value that is not reachable from r and is not freely reachable from any variable other than r.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"\nint[] a = [];\n\nint[][] b = [a];\n\n// Neither `a` nor `b` (and values assigned to them) are isolated roots.\n\nint[] c = [];\n\nint[][] d = [[], [1, 2]];\n\nint[][] e = [a.clone(), c.clone(), []];\n\n// All of `c`, `d`, and `e` are isolated roots.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"#### Isolated expressions\n\nAn [isolated expression](https://ballerina.io/spec/lang/master/#isolated_expressions) provides the guarantee\n\n> that the value of the expression will be an isolated root and will not be aliased\n\nIf the static type of an expression is immutable (i.e., subtype of `readonly`) or an `isolated` object (covered later), the expression is an isolated expression, irrespective of the expression kinds, subexpressions, etc.\n\n- `clone()` and `cloneReadOnly()` are always `isolated` since they always create new and/or immutable values\n- constructor expressions (e.g., list constructor) and some other kinds of expressions are isolated if all of their subexpressions are isolated\n- for other kinds of expressions, where applicable, the spec defines rules specifying when they can be isolated","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"#### Maintaining the isolated root invariant with `isolated` variables\n\nIn order to maintain the isolated root invariant, the compiler requires any update to an isolated variable happens via isolated expressions. This applies to any update including initialization, setting a value, retrieving a value, etc.\n\nThis is analyzed along with the lock statements used to access these variables. The lock statements are the boundaries across which transfer in and out are analyzed when special values such as isolated variables are accessed. Therefore, special rules apply in such lock statements.\n\nQuoting the [spec](https://ballerina.io/spec/lang/master/#lock-stmt):\n\n> - Only one such variable can occur in the lock statement.\n> - A function or method can be called in the lock statement only if the type of the function is isolated.\n> - Transferring values out of the lock statement is constrained: the expression following a return statement must be an isolated expression; an assignment to a variable defined outside the lock statement is allowed only if left-hand side is just a variable name and the right hand side is an isolated expression. An assignment to the restricted variable is not subject to this constraint.\n> - Transferring values into the lock statement is constrained: a variable-reference-expr within the lock statement that refers to a variable or parameter defined outside the lock statement is allowed only if the variable-reference-expr occurs within an expression that is isolated. A variable-reference-expr that refers to the restricted variable is not subject to this constraint. Within a non-isolated object, self behaves like a parameter.\n","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"int[] a = [];\n \n // error for `a` now - invalid initial value expression: expected an isolated expression \nisolated int[][] b = [[1, 3], a, [4]];\n\nfunction f1(int[] arr) {\n    lock {\n        // error for transferring in `arr` when accessing isolated variable `b` - \n        // invalid attempt to transfer a value into a 'lock' statement with restricted variable usage\n        b.push(arr);\n    }\n}\n\nfunction f2() returns int[] {\n    lock {\n        // error for transferring a value out when accessing isolated variable `b` -\n        // invalid attempt to transfer out a value from a 'lock' statement with restricted variable usage: expected an isolated expression\n        return b[0];\n    }\n}\n\npublic function main() {\n    int[] x = [1, 2];\n    f1(x);\n\n    int[] y = f2();\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"If any of these were allowed, it would violate the isolated root invariant\n- if just `a` was allowed in the list constructor initializing `b`, the same mutable value would be reachable via both `a` and `b`\n- if `b.push(arr)` was allowed in `f1`, the last member of `b` would be reachable via both `b` and the variable `x` in the `main` function\n- if `return b[0]` was allowed in `f2`, the first member of `b` would be reachable via both `b` and the variable `y` in the `main` function\n\nWe can fix these errors using isolated expressions appropriately.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"int[] a = [];\n \nisolated int[][] b = [[1, 3], a.clone(), [4]];\n\nfunction f1(int[] arr) {\n    lock {\n        b.push(arr.clone());\n    }\n}\n\nfunction f2() returns int[] {\n    lock {\n        return b[0].clone();\n    }\n}\n\npublic function main() {\n    int[] x = [1, 2];\n    f1(x);\n\n    int[] y = f2();\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"### Isolated objects\n\nIn the previous order service snippets, we had mutable state as module-level variables. But what about object (and therefore, service) fields that are mutable? \n\nSimilar to module-level variables, mutability depends on two things\n- whether the field is `final`\n- whether the type of the field is a subtype of `readonly`\n\nIs it enough for just object methods to be `isolated`?","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"class Stacks {\n    int[][] list = [];\n\n    isolated function get(int i) returns int[] {\n        return self.list[i];\n    }\n\n    isolated function put(int[] arr) {\n        self.list.push(arr);\n    }\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"**Note:** `self` can be accessed within an `isolated` method. Here, `self` is is analyzed like a parameter to the method.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"While both methods are `isolated`, note how `Stacks` is not an isolated root.\n\n- the `list` field is not immutable and is not private. `list` and it's members can be accessed in a manner that is not concurrency-safe, wherever a `Stacks` object is accessible\n- retrieving and updating the mutable fields can be done in a manner than violates the isolated root invariant\n\nMoreover, mutable fields of the object can be accessed in an unsafer manner, without locks, even when the methods are `isolated`.\n\nTherefore, for a method call to be safe, it is not enough for just the method to be `isolated`. We need a mechanism to ensure that the object is also safe - ebter isolated objects.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"To ensure that an object is an `isolated` object, an additional set of constraints apply.\n\n- mutable (non-final and/or mutable value) fields have to be private\n- when `self` is used to access a mutable field, rules similar to those applicable when accessing an `isolated` variable apply","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"isolated class Stacks {\n    private int[][] list = []; // private field\n\n    isolated function get(int i) returns int[] {\n        lock { // use of locks\n            return self.list[i].clone(); // use of isolated expressions to transfer in/out\n        }\n    }\n\n    isolated function put(int[] arr) {\n        lock {\n            self.list.push(arr.clone());\n        }\n    }\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"Accordingly, if the mutable state of the order service were non-private fields of the service object, warnings will still be logged even if the methods are isolated.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"import ballerina/http;\n\nconfigurable int port = 8080;\n\nenum CakeKind {\n    BUTTER_CAKE = \"Butter Cake\",\n    CHOCOLATE_CAKE = \"Chocolate Cake\",\n    TRES_LECHES = \"Tres Leches\"\n}\n\nenum OrderStatus {\n    PENDING = \"pending\",\n    IN_PROGRESS = \"in progress\",\n    COMPLETED = \"completed\"\n}\n\ntype OrderDetail record {|\n    CakeKind item;\n    int quantity;\n|};\n\ntype Order record {|\n    string username;\n    OrderDetail[] order_items;\n|};\n\ntype OrderUpdate record {|\n    OrderDetail[] order_items;\n|};\n\nservice on new http:Listener(port) {\n    map<Order> orders = {};\n    map<OrderStatus> orderStatus = {};\n\n    // concurrent calls will not be made to this method since the service is not an 'isolated' service\n    resource function get 'order/[string orderId]() returns http:Ok|http:NotFound {\n        if !self.orderStatus.hasKey(orderId) {\n            return <http:NotFound>{};\n        }\n\n        return http:OK;\n    }\n\n    // concurrent calls will not be made to this method since the service is not an 'isolated' service\n    resource function delete 'order/[string orderId]() returns http:Ok|http:Forbidden|http:NotFound {\n        if !self.orderStatus.hasKey(orderId) {\n            return <http:NotFound>{};\n        }\n\n        if self.orderStatus.get(orderId) != PENDING {\n            return <http:Forbidden>{};\n        }\n        _ = self.orderStatus.remove(orderId);\n\n        _ = self.orders.remove(orderId);\n\n        return http:OK;\n    }\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"Once we fix the object to be an isolated object, these warnings will also go away.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"import ballerina/http;\n\nconfigurable int port = 8080;\n\nenum CakeKind {\n    BUTTER_CAKE = \"Butter Cake\",\n    CHOCOLATE_CAKE = \"Chocolate Cake\",\n    TRES_LECHES = \"Tres Leches\"\n}\n\nenum OrderStatus {\n    PENDING = \"pending\",\n    IN_PROGRESS = \"in progress\",\n    COMPLETED = \"completed\"\n}\n\ntype OrderDetail record {|\n    CakeKind item;\n    int quantity;\n|};\n\ntype Order record {|\n    string username;\n    OrderDetail[] order_items;\n|};\n\ntype OrderUpdate record {|\n    OrderDetail[] order_items;\n|};\n\nservice on new http:Listener(port) {\n    private map<Order> orders = {};\n    private map<OrderStatus> orderStatus = {};\n\n    resource function get 'order/[string orderId]() returns http:Ok|http:NotFound {\n        lock {\n            if !self.orderStatus.hasKey(orderId) {\n                return <http:NotFound>{};\n            }\n        }\n\n        return http:OK;\n    }\n\n    resource function delete 'order/[string orderId]() returns http:Ok|http:Forbidden|http:NotFound {\n        lock {\n            if !self.orderStatus.hasKey(orderId) {\n                return <http:NotFound>{};\n            }\n\n            if self.orderStatus.get(orderId) != PENDING {\n                return <http:Forbidden>{};\n            }\n            \n            _ = self.orderStatus.remove(orderId);\n        }\n\n\n        lock {\n            _ = self.orders.remove(orderId);\n        }\n\n        return http:OK;\n    }\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"Based on this analysis of both objects and methods, a listener can identify when and if it is safe to call a service remote or resource method concurrently, as long as the listener can guarantee exclusive access to the mutable arguments, if applicable.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"#### Using `isolated` objects within `isolated` functions\n\nWith module-level state that is `final` but not immutable, we previously saw how we needed to use lock statements when accessing such variables in `isolated` functions.\n\nBut what about a `final` variable that holds an `isolated` object? Since the `isolated` object guarantees that any mutable state is accessed within a lock statement, we do not have to use locks when using such a variable within an isolated function.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"isolated class Stacks {\n    private int[][] list = [];\n\n    isolated function get(int i) returns int[] {\n        lock {\n            return self.list[i].clone();\n        }\n    }\n\n    isolated function put(int[] arr) {\n        lock {\n            self.list.push(arr.clone());\n        }\n    }\n}\n\nStacks s1 = new; // neither final nor an isolated variable\n\nisolated Stacks s2 = new; // isolated variable\n\nfinal Stacks s3 = new; // final\n\nisolated function fn() {\n    _ = s1.get(0); // error: invalid access of mutable storage in an 'isolated' function\n\n    _ = s2.get(0); // error: invalid access of an 'isolated' variable outside a 'lock' statement\n\n    lock {\n        _ = s2.get(0); // OK, because `s2` is an isolated variable, and access is within a lock.\n    }\n\n    _ = s3.get(0); // OK, because `s3` is a `final` variable of an isolated object type\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"### Workers and async calls within `isolated` functions\n\nThere also may be scenarios where we want to have workers or do async calls within an `isolated` function (and have the strands run on separate thread). In order to allow this, we need to ensure that whatever mutable access that happens within these constructs happens safely.\n\nFor workers, this means that the worker body should meet the requirements for an `isolated` function and that captired variables are final and have a static type that is a subtype of `readonly|isolated object {}`.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"import ballerina/io;\n\nint[] x = [];\nfinal int[] & readonly y = [];\n\npublic isolated function main() {\n    io:println(x); // error\n    io:println(y); // OK\n\n    int[] localX = [];\n    final int[] & readonly localY = [];\n\n    // Similarly\n    worker w {\n        io:println(x); // error\n        io:println(y); // OK\n\n        io:println(localX); // error\n        io:println(localY); // OK\n    }\n}","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"For an aync call (`start` action), this requires the function to be `isolated` and any argument to the function to be an isolated root. That way we can ensure mutable state isn't accessed concurrently by these strands.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":2,"language":"ballerina","value":"type Config record {\n\n};\n\npublic isolated function main() {\n    Config config = {};\n    string[] urls = [];\n\n    foreach string  url in urls {\n        future<string> fr = start getResult(url, config.clone());\n    }\n\n    // or\n    final readonly & Config immutableConfig = config.cloneReadOnly();\n    foreach string  url in urls {\n        future<string> fr = start getResult(url, immutableConfig);\n    }\n}\n\nisolated function getResult(string url, Config config) returns string {\n    // \n    return \"\";\n}\n","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"Such strands can safely scheduled on different threads.","outputs":[],"executionSummary":{},"metadata":{}},{"kind":1,"language":"markdown","value":"### Inferring isolated\n\nEnd users are generally not expected to explicitly add `isolated`. If the written code is safe (i.e., no compilation errors if `isolated` was added explicitly), the compiler will infer `isolated`.\n\nLibrary developers, on the other hand, and others who develop publicly exposed constructs are expected to explicitly add `isolated` to guarantee `isolated`, which will eventually lead to inferring `isolated` for user code.","outputs":[],"executionSummary":{},"metadata":{}}]